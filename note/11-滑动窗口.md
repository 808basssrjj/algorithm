



## 1. 窗口

窗口就是一种特定的运动轨迹。

一开始窗口的左边界和右边界都停留在整个数组的最左侧，窗口是空的。

窗口的左边界 L 和右边界 R 只能向右移动，不能向左移动。同时在移动时必须遵循一个原则：左边界 L 一定不能移动到右边界 R 的右边（L 不能超越 R）。

只要不违反原则，L 和 R可以随时向右移动。

当 R 往右移动，表示数组中有若干个元素从窗口的右侧进窗口。

当 L 往右移动，表示数组中有若干个元素从窗口的左侧出窗口。

如果我们需要获得当前窗口状态下的最大值，通常做法是遍历整个窗口，这样代价就不够低。那么能不能通过某一种结构，使用很低的代价就能获得当前窗口状态的最大值或者最小值？

就是**窗口内最大值或最小值更新结构**。



## 2. 最大值更新结构

在任意窗口状态下得到窗口中最大值的结构。

双端队列中存储的是数组中元素的下标。为什么不存储元素？是因为下标不仅仅能够表示元素，还能表示元素在数组中的位置，携带的信息更多。

**如果是最大值更新结构，那么单调性是从大到小的，也就是需要保证双端队列从头到尾存储的下标对应的元素是从大到小的。**



**R 向右移动一位：**

- 如果双端队列为空，那么 R 新囊括的元素的下标从尾部直接进入双端队列。

- 如果双端队列不为空，则 R 新囊括的元素需要与双端对列尾部的下标所指向的元素进行比较：
  - 如果新囊括的元素比双端对列尾部下标所指向的元素小，则直接从尾部进入双端对列。
  - 如果新囊括的元素比双端对列尾部下标所指向的元素大或者相等，则将尾部的下标从尾部弹出双端队列，让新囊括的元素与当前尾部下标所指向的元素继续比较。

**L 向右移动一位：**这里匹配的是下标，而不是下标所对应的元素值。

- 只需要将 L 新排出的元素对应的下标和双端队列头部的下标进行比较：
  - 如果新排出的元素对应的下标和双端队列头部下标一致，则将头部的下标从头部弹出双端队列。
  - 如果新排出的元素对应的下标和双端队列头部下标不一致，无需任何操作。



只要从双端队列尾部弹出的下标永远不找回。

任何时候双端队列的**最大值都是头部**存储的元素或者元素代表的值。

设计这种规则实际上就是在严格维护双端队列的单调性。





## 3. 原理

为什么每一个窗口状态的最大值都是当前双端队列头部的值呢？

那就需要研究双端队列到底维持的是什么信息。

维持的是**如果此时不让 R 向右移动而选择让 L 依次向右移动，谁会依次成为最大值**这个信息。

假设现在有一个数组 arr =  { 6，5，4，3，5，7 }，窗口区域是 [ 6，5，4，3 ]。

![20211015180222.png](img\window.png)

此时双端队列维持的最大值是 arr[0] = 6。

如果让 R 不动，L 向右移动一位，则 arr[0] 过期，arr[1] 成为了最大值。L 再向右移动一位，则 arr[1] 也过期了，arr[2] 成为了最大值。以此类推。

如果让 L 不动，R 向右移动一位，则 3、2 和 1 都要依次弹出，再让 4 进入。

3、2 和 1 弹出的原因是 arr[4] = arr[1] > arr[2] > arr[3]，且 arr[1]、arr[2] 和 arr[3] 又一定比 arr[4] 更早过期，所以 arr[1] 、arr[2] 和 arr[3] 再也没有机会成为最大值了，因此可以直接从双端队列中弹出，让 arr[4] 压入双端队列就足够了。

因此，也可以说双端队列维持的是**如果依次过期，谁会依次成为最大值**这个信息。



## 4.  时间复杂度

当窗口在数组中向右滑动的时候，统计每个元素进出窗口的次数即可。

每一个元素最多进窗口1次，最多出窗口1次。已经出窗口的元素是不会再重新回到窗口的，所以不存在一个元素多次进窗口的情况。

所以当窗口向右滑动的元素是 N 个，双端队列更新的总代价一定是O(N)，单次更新的代价就是O(N) / N，因此单次的平均代价就是O(1)。

> 注意，只是平均代价是O(1)，并不代表每一次更新都是O(1)。
>
> 比如 arr = { 6，5，4，3，2，1，7 }，窗口为 [ 6，5，4，3，2，1 ] 此时 L 动，R 向右移动一位，此时双端队列更新的代价为O(N)。但是 0~5 位置进入窗口双端队列更新代价都是O(1)，可以说在某一个时刻，单个元素更新的复杂度可能比较高，但是总的代价平均下来是非常低的。





## 5. 代码实现

```go
// MaxWindow 获得窗口最大值(队列的头元素)的结构
// L和R移动时都要保持队列头到尾递减
type MaxWindow struct {
	r  int
	l   int
	arr []int
	ls  []int
	//双端队列存的是 arr的下标
	//双端队列维持的是如果此时不让 R 向右移动而选择让 L 依次向右移动，谁会依次成为最大值这个信息。
	//ls  list.List
}

func NewMaxWindow(arr []int) *MaxWindow {
	return &MaxWindow{
		r:   0,
		l:   -1,
		arr: arr,
		ls:  make([]int, 0, len(arr)),
		//ls:  list.List{},
	}
}

// AddFromRight R移动时
// 从尾部加入,需从尾部弹出<=加入值的数
func (w *MaxWindow) AddFromRight() {
	if w.r == len(w.arr) {
		return
	}

	cur := len(w.ls) - 1
	for len(w.ls) != 0 && w.arr[w.ls[cur]] <= w.arr[w.r] { //从尾部弹出所有 <=加入值的数
		w.ls = w.ls[:cur]
		cur--
	}
	w.ls = append(w.ls, w.r)
	w.r++
}

// RemoveFromLeft L移动时
// 如果删除的值是最大值,从队列中删除最大值
func (w *MaxWindow) RemoveFromLeft() {
	if w.l >= w.r-1 {
		return
	}

	w.l++
	if w.ls[0] == w.l {
		w.ls = w.ls[1:]
	}
}

// GetMax 获得窗口最大值
func (w *MaxWindow) GetMax() int {
	if len(w.ls) != 0 {
		return w.arr[w.ls[0]]
	}
	return 0

```

