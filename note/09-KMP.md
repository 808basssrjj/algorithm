## 1. 引入

KMP算法中最著名的应用就是 "求子串问题"。

**题目**：

现在有str1="abcd1234efg" 和str2="1234"，如何判断str2是不是str1的子串？

注意，子串必须是连续一段，比如 "1234f" 就不是 "abcd1234efg" 的子串，但是 "1234e" 是。

**分析**：

本题如果使用暴力解法，则尝试方法是从左往右尝试str1中每一个字符是否能够配出str2。

暴力解法在一种极端的情况下，时间复杂度会非常高。比如：str1="1111111112"，str2="11112"。如果要用暴力解法，则str1从第一个字符1向后配了5次发现配不上，再从第二个字符1向后又配了5次发现配不上，以此类推，直到str1最后一段才配上。如果str1长为N，str2长为M，则时间复杂度为O(NM)，相当于str1每走一步就需要遍历整个str2。

如果使用KMP算法解决该问题，则返回类型不是boolean，而是返回子串在str1中第一个字符的下标，如果不包含返回-1。

KMP和暴力解法核心思想是一样的，都是从左往右尝试str1中每一个字符是否能够配出str2，但是KMP有加速。



## 2. 最大匹配长度

在将KMP算法解决 "求子串问题"，我们首先要理解一个概念，就是**最长前缀和后缀的匹配长度**。

最长前缀和后缀的匹配长度是子串（str2）中每一个字符都需要携带的信息，**该信息与对应的字符无关，但是与对应字符的前面所有字符有关**。

比如说有一个字符串 "abbabbk"，我们想要知道k字符的最长前缀后后缀的匹配长度。

首先我们需要获取k字符前面的字符串 "abbabb"，然后求出 "abbabb" 字符串前缀和后缀的最大匹配长度为3，k字符携带的信息就是3。

> 前缀和后缀都不能取到字符串整体。
>
> 如果该字符前面没有字符串，则该字符携带的信息就是 -1。
>
> 人为规定字符串0位置的字符携带的是 -1，1位置的字符携带的是0。



求 i 位置next , 主要看 i-1位置: 比较i-1字符 和i-1位置next值的字符(cn)是否相等

	1. 如果相等 i 的next值等于 i-1的next值+1
	2. 如果不相等cn向前跳
	3. 如果cn来到0位置, 及无法再向前跳了, i 的next值就为0

例:

(abbstabb)ec(abbstabb)ex   x:9 跳一次
(abbstabb)ec(abbstabb)sx   x:4 跳两次
(abbstabb)ec(abbstabb)yx   x:0 来到0位置

```go
func getNext(str string) []int {
    if str == '' {
        return nil
    }
    next := make([]int, len(str))
    next[0], next[1] = -1, 0
    
    i, cn := 2, 0 //cn既代表哪个字符和i-1字符比，也代表i-1的next值
    for i < len(str) {
        if next[i-1] == cn {
            next[i] = cn + 1
            //求出i的next后, 更新cn, i跳下一个
            cn = next[i] 
            i++
        } else if cn > 0 {
            cn = next[cn]
        } else {
            next[i] = 0
            i++
        }
    }
    return next
}
```



## 3. 加速流程

如果str1 从 i到x-1位置都和 str2 的0到y-1位置相等,  但x != y

那么 y 向前移动到y的next值位置y'(最大前缀的下一个字符)

``` 
从
i......x
0......y
到
i...j....x
0...y'...y
    0....y'...
```

相当于把str2向右推,来比较str1的x和str2的y,  本质是从 j 位置开始匹配

此时要解决两个问题

1. 为什么  [ j, x-1] 位置可以直接跳过, 无需比较?   

   因为匹配时, [ j, x-1] 位置 == [ y', y-1] 位置

​		又因为根据next数组的定义  [ 0, y'-1] 位置 == [ y', y-1]  位置

​		所以  [ j, x-1] 位置 == [ 0, y'-1] 位置

2. 为什么 [ i, j-1] 位置一定匹配不出来?  

   假设[ i, j-1] 位置  有Z位置可以匹配出完整的 str2

   所以  [z, x-1] == 0到某个位置A  等量的长度

   i .......[z ......j ....]x

   [0...... (z'.A]....y'....)y

   又因为匹配时, [z, x-1] == [z', y-1]

   所以  [0, A] == [z', y-1]

   所以 y的next 应该为 z'到y-1的长度, 而不是y'到y-1的位置

   假设不成立

```go
func KMP(str1, str2 string) int {
    if len(str1) < 1 || len(str2) < 1 ||  len(str1) < len(str2) {
        return -1
    }
    next := getNext(str2)
    var i1, i2 int
    for i1 < len(str1) && i2 < len(str2) {
        if str1[i1] == str2[i2] {
            i1++
            i2++
        } else if next[i2] > -1 {
            i2 = next[i2]
        } else { // next[i2]==-1 或i2==0
            i1++
        }
    }
    // i1越界代表没匹配到 i2越界代表匹配到了
    if i2 == len(str2) {
        return i1 - i2
    } else {
        return -1
    }
}
```



## 4. 完整流程

实际上KMP的整个流程就是str2一直右移的过程。

我们抛开KMP常数优化的过程，仔细分析一下KMP加速的本质流程。

![20211011204348.png](C:\Users\Administrator\Desktop\study\algorithm\note\img\kmp.png)

KMP为什么很快？拿str1中a~e举例子，使用经典方法需要比较17次，而使用KMP只需要比较4次，如果加上KMP的常数加速，那么在4次比较中将会更快。

其中，①、②、③和④是4次匹配开始时str1和str2的比较位置，实际上代表了KMP对str1中a~e这一段完整的加速流程。

在匹配指针指向str1的①位置开始匹配时，直到发现 e 和 w 匹配不上，因此①位置匹配失败。

然后找出str2中 w 的最长前后缀为：abbsabb。匹配指针指向②位置开始匹配，直到发现 e 和 t 匹配不上，因此②位置匹配失败。

然后找出str2中 t 的最长前后缀为：abb。匹配指针指向③位置开始匹配，直到发现 e 和 s 匹配不上，因此③位置匹配失败。

然后找出str2中 s 的最长前后缀为：无。匹配指针指向④位置开始匹配，发现 e 和 a 匹配不上，因此④位置匹配失败。

str1中a~e已经全部和str2匹配完，任何一个位置开始匹配都匹配不出str2，因此匹配指针指向 e 的后面一位⑤开始匹配，继续循环执行①位置的操作，周而复始，直到str1最后一位结束。



## 5. 复杂度

通过观察代码 process，我们可以发现第一个分支中 i1 和 i2 都增大；第二个分支中 i1 增大；第三个分支中 i2 减小。

估计while的复杂度时，我们需要假设两个量，第一个量是 i1，第二个量是 i1 - i2。

假设str1长度为N，那么 i1 和 i1 - i2 的最大值都是N。

我们要看循环中的三个分支分别对这两个量的影响。

|            | i1 (max -> N) | i1-i2 (max -> N) |
| ---------- | ------------- | ---------------- |
| 第一个分支 | 增大          | 不变             |
| 第二个分支 | 增大          | 增大             |
| 第三个分支 | 不变          | 增大             |

循环的第一个分支，i1 和 i2 一起增加。因此 i1 增加，i1 - i2 不变。

循环的第二个分支，i1 增加。因此 i1 增加，i1 - i2 增加。

循环的第三个分支，i2 减少。因此 i1 不变，i1 - i2 增加。

每一次循环只会走一个分支，因此将这两个量的变化范围叠加起来，最大的幅度就是2N（走第二个分支，且都是N）。

三个分支都不会让两个量中任何一个量减少，因此循环发生的次数就和两个量变化范围的叠加绑定在了一起，两个量变化的幅度就是while循环的次数，所以整个while循环的次数不会超过2N。

因此可以证明while的时间复杂度是线性的，为**O(N)**。

**然后证明getNexts方法的复杂度：**

估计getNexts的复杂度时，我们也需要假设两个量，第一个量是 i，第二个量是 i - prefix。

假设str2长度为M，i 的最大值是M，i - prefix的最大值也是M。



|            | i1 (max -> M) | i-prefix(max -> M) |
| ---------- | ------------- | ------------------ |
| 第一个分支 | 增大          | 不变               |
| 第二个分支 | 不变          | 增大               |
| 第三个分支 | 增大          | 增大               |

循环的第一个分支，i 和 prefix 一起增加。因此 i 增加，i - prefix 不变。

循环的第二个分支，prefix 减少。因此 i 不变，i - prefix 增加。

循环的第三个分支，i 增加。因此 i 增加，i - prefix 增加。

每一次循环只会走一个分支，因此将这两个量的变化范围叠加起来，最大的幅度就是2M（走第三个分支，且都是N）。

因此可以证明getMaximalPrefixAndSuffix的时间复杂度是线性的，为O(M)。

**总体时间复杂度为：**

因为M一定小于等于N，所以KMP整体时间复杂度为O(N)。


