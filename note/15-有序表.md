## 一. 有序表介绍

有序表和哈希表的本质区别就是：哈希表的Key是通过Hash函数散列组织的，而有序表的Key是顺序组织的。

有序表除了支持哈希表的所有操作之外，还提供了一些由于Key的有序性可以实现的其他操作。例如：找到最大或最小的Key对应的Value、给定一个Key找到比它小且最近的Key对应的Value是多少......

有序表所有操作的时间复杂度都是O(logN)，非常高效。

很多结构都可以实现有序表。例如：红黑树（Red Black tree）、AVL树、SB树（Size Balanced Tree）、跳表（Skip List）...... 这些数据结构实现的有序表的性能指标都一样，都是O(logN)。由于它们各自实现有序表的原理不同，因此即使时间复杂度有区别也只是常数时间的差距，而且常数时间的差距也比较小。

不同数据结构实现有序表分成两大系列：

- 平衡搜索二叉树系列：
  - 红黑树
  - AVL树
  - SB树
- 跳表系列：跳表





## 二. 搜索二叉树

平衡搜索二叉树，首先是一棵搜索二叉树，其次才涉及到平衡性的问题。

首先想一个问题：**如果不考虑平衡性，如何在一棵搜索二叉树中实现数据的增删改查？**



### 1. 搜索流程

搜索二叉树有固定的搜索流程，增删改查所有操作都需要基于搜索流程来完成具体的实现。

搜索流程是：目标Key先和根的Key进行比较，如果比根的Key小，则进入根的左子树继续搜索；如果比根的Key大，则进入根的右子树继续搜索，周而复始。

**由于AVL树、SB树和红黑树也是搜索二叉树，因此也遵循该搜索流程完成增删改查的操作，只是它们各自在完成操作后如果平衡性被破坏会自动进行调整罢了。**

### 2. 查询数据

目标Key进入搜索流程，如果查询到有该节点，则返回；如果没有，则返回统一错误。

### 3. 增加数据

如果添加一个数据，直接通过搜索流程找到对应的添加位置进行添加。

如果要增加一组数据，就先将需要组织的数据排列好，依次通过搜索流程找到对应的添加位置，然后加入。

一般默认一棵搜索二叉树上是没有重复节点的（Key），可以在搜索二叉树的每一个节点上增加数据项作为伴随数据（数据压缩），无论需要组织的数据多么复杂，都可以使用该方式解决。这样既能保证数据不会丢失，也能保证整个搜索二叉树没有重复节点。

![](C:\Users\Administrator\Desktop\study\algorithm\note\img\ordered.png)

### 4. 更新数据

目标Key如果能通过搜索流程在树中找到对应节点，就对该节点数据进行更新；如果找不到对应节点，则新建一个节点添加到搜索二叉树的对应位置。

### 5. 删除数据

删除数据就不是很容易了，为什么呢？

因为删除数据时需要分情况讨论：





## 三. 平衡搜索二叉树

搜索二叉树有一个问题，它没有平衡性，没有平衡性就会让搜索二叉树的操作的代价无法维持在O(logN)的水平。

**搜索二叉树的操作的时间复杂度取决于数据状况**，假设现在需要组织 [1，2，3，4，5，6] 这些数据成一棵搜索二叉树，那么在这棵二叉搜索树上进行增删改查的代价就会比O(logN)大，达到O(N)的代价，因为此时的搜索二叉树相当于一个单链表。

因此，就有了这样一个问题：**搜索二叉树如何兼顾平衡性？**

### 1. 平衡性

平衡性分为狭义平衡性和广义平衡性。

- **狭义平衡性**：AVL树，红黑树，SB树等一些平衡树自己单独定义的平衡性。例如AVL树那样非常严苛的平衡性，任何一个节点的左子树和右子树高度差的绝对值不超过1。
- **广义平衡性**：任何一个节点的左子树规模和右子树体量不会相差的太悬殊。这种体量，可以是树的深度，也可以是节点个数。

狭义平衡性是广义平衡性的一个具体实现。只要搜索二叉树能够兼顾广义平衡性，那么就能将操作代价维持在O(logN)的水平，更不用说狭义平衡性了。

### 2. 左旋和右旋

**定义：**

施加在搜索二叉树上的两个动作，**搜索二叉树依靠使用左旋和右旋这两个动作来实现自身平衡性的调整**。



**AVL树、红黑树和SB树都是对平衡搜索二叉树的具体实现，它们每一个对于自身平衡性的定义都不一样，对于自身如何使用左旋和右旋达到平衡的方式也都不一样**。可以说它们通过对左旋和右旋的具体使用方式的不同，来维持自身定义的不同的平衡性。