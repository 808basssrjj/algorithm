## 1. 引入

单调栈解决的是这样一个问题，比如说给一个数组arr = { 5，4，6，7，2，3，0，1 }，我想知道每一个元素左边比该元素大且离得最近的元素和右边比该元素大且离得最近的元素都是什么。

如果数组有 N 个元素，经典解法就是来到 i 位置，左边遍历直到比 arr[i] 大的元素为止，右边遍历直到比 arr[i] 大的元素为止。确定一个位置的时间复杂度为O(N)，确定 N 个位置的时间复杂度就是O(N^2)。

能不能将确定 N 个位置的时间复杂度降到O(N)？单调栈结构。

同样，如果使用单调栈能够找到每一个元素左边和右边比该元素大且离得最近的元素，同样也能找到每个元素左边和右边比该元素小且离得最近的元素。



## 2. 流程（无重复）

单调栈本身是支持数组中有重复值的，但是我们为了讲清原理，举得例子中数组是没有重复值的。

首先，准备一个栈。

栈中存储的是数组中**元素的下标**。为什么不存储元素？是因为下标不仅仅能够表示元素，还能表示元素在数组中的位置，携带的信息更多。

**如果要找到数组中每一个元素左右两边比该元素大且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从大到小的。**

**如果要找到数组中每一个元素左右两边比该元素小且离得最近的元素，那么单调栈要保证从栈底到栈顶存储的下标对应的元素是从小到大的。**



从头开始遍历数组：

- 如果栈中没有元素，直接将元素的下标压栈。
- 如果栈中有元素，当前元素和栈顶的下标所指向的元素进行比较：
  - 当前元素比栈顶的下标所指向的元素小，将当前元素的下标压栈。
  - 当前元素比栈顶的下标所指向的元素大，栈顶的下标弹栈，同时记录原栈顶下标对应的元素的信息。原栈顶下标对应的元素**左边**比该元素大且离得最近的元素就是在栈中原栈顶下标**压在下面的相邻下标对应的元素**；原栈顶下标对应的元素**右边**比该元素大且离得最近的元素就是**让它的下标弹栈的下标对应的元素**。记录完之后，当前元素继续和新栈顶下标对应的元素进行比较。如果栈中只有一个下标，则该下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。

当数组遍历完后，如果栈中还有下标，则进入清算阶段：

- 如果不是最后一个下标，依次弹出栈顶下标，原栈顶下标对应的元素左边比该元素大的且离得最近的元素就是在栈中原栈顶下标压在下面的相邻下标；原栈顶下标对应的元素右边没有比该元素大的且离得最近的元素。
- 是最后一个下标，弹出该下标，该下标对应的元素没有左边比该元素大的且离得最近的元素，也没有右边没有比该元素大的且离得最近的元素。





## 3. 流程（有重复）

假设数组中有重复值，那么单调栈中存储的元素就不能只是一个下标了，可能会存储多个下标，这多个下标对应的数组中的值是一样的。

因此在实现上，我们偏向去使用一个链表来作为单调栈的元素类型，**同一个链表中所有下标指向的元素值是一样的**。

**这种结构可以处理有重复值的数组，也可以处理无重复值的数组，是万能的。**

流程上和无重复的大致相同，区别在于：

- 当前元素比栈顶的下标链表所指向的元素大，栈顶的下标链表弹栈，同时记录原栈顶下标链表中每一个下标对应的元素的信息。原栈顶下标链表中每一个下标对应的元素左边比该元素大且离得最近的元素都是在栈中原栈顶下标链表压在下边的相邻下标链表的最后一个下标对应的元素；原栈顶下标链表中每一个下标对应的元素有右边比该元素大且离得最近的元素就是让它的下标链表弹栈的下标链表中的下标对应的元素（此时下标链表中只会有一个元素）。如果栈中只有一个下标链表，则该链表中所有下标左边没有比该下标对应的元素大且离得最近的元素，右边正常。
- 当前元素与栈顶的下标链表所指向的元素相等，将该元素对应的下标连接到栈顶的下标链表的末尾



## 4. 时间复杂度

为什么说使用单调栈可以将时间复杂度降低至O(N)？

假设有数组中有 N 个元素，在我们计算出了所有元素的左右边比该元素大或者小且离得最近的元素的整个过程中，无论是使用有重复的模型还是无重复的模型，每一个元素都只进栈一次，出栈一次。





## 5. 原理（无重复）

为什么数组中没有重复值，单调栈可以做到以O(N)的代价找到每个元素左右边比该元素大且离得最近的元素？

假设当前有一个单调栈，栈中有 a 和 b。 现在 c 要压栈，已知 arr[c] > arr[b]，因此 b 需要先弹出栈，在 b 弹栈时记录 b 的相关信息。

为什么 arr[b] 左边比 arr[b] 大且离得最近的元素一定是 arr[a] ？

为什么 arr[b] 右边比 arr[b] 大且离得最近的元素一定是 arr[c] ？

![20211016094715.png](C:\Users\Administrator\Desktop\study\algorithm\note\img\stack1.png)

**证明：arr[b] 右边比 arr[b] 大且离得最近的元素是 arr[c]。**

因为是从左往右依次遍历数组的，b 比 c 先进了栈，表示 arr[b] 比 arr[c] 先遍历到，因此 arr[c] 一定在 arr[b] 的右边。

那么我们看 b~c 之间，有没有可能有一个 k 使得 arr[k] > arr[b] ?

不可能，如果在 b~c 之间有一个 arr[k] > arr[b]，那么肯定先遍历到 k，当遍历到 k 的时候，为了保证栈的单调性，一定会将 b 弹栈，根本轮不到 c 来让 b 弹栈。

**证明：arr[b] 左边比 arr[b] 大且离得最近的元素是 arr[a]。**

因为是从左往右依次遍历数组的，a 比 b 先进了栈，表示 arr[a] 比 arr[b] 先遍历到，因此 arr[a] 一定在 arr[b] 的左边。

那么我们看 a ~ b 之间，有没有可能有一个 k 使得 arr[k] > arr[b]？

此时我们知道 arr[a] > arr[b]，arr[k] > arr[b]，因此我们需要讨论一下 arr[a] 和 arr[k] 的关系：

- 如果 arr[k] > arr[a]，因为 k 一定比 a 后遍历到，因此在遍历到 k 时一定会让 a 弹栈，等遍历到 b 让 b 压栈时根本碰不到 a，因此这种情况不可能。
- 如果 arr[k] < arr[a]，因为 k 一定比 a 后遍历到，因此在遍历到 k 时 k 一定会压在 a 的上面。因为 arr[k] > arr[b]，且 b 比 k 后遍历到，因此等遍历到 b 时，b 压栈时一定会和 a 之间隔一个 k，a 和 b 根本不会相邻，因此这种情况也不可能。



## 6. 原理（有重复）

为什么数组中有重复值，单调栈也可以做到以O(N)的代价找到每个元素左右边比该元素大且离得最近的元素？

假设当前有一个单调栈，栈中有 a、b、c、d 和 e。 现在 e 要压栈，已知 arr[e] > arr[d]，因此 d 需要先弹出栈，在 d 弹栈时记录 b 的相关信息。

为什么 arr[d] 左边比 arr[d] 大且离得最近的元素一定是 arr[c] ？

为什么 arr[d] 右边比 arr[d] 大且离得最近的元素一定是 arr[e] ？

![20211016182642.png](C:\Users\Administrator\Desktop\study\algorithm\note\img\stack2.png)

**证明：arr[d] 右边比 arr[d] 大且离得最近的元素是 arr[e]。**

与无重复同理。

**证明：arr[d] 左边比 arr[d] 大且离得最近的元素是 arr[c]。**

因为是从左往右依次遍历数组的，c 比 d 先进了栈，表示 arr[c] 比 arr[d] 先遍历到，因此 arr[c] 一定在 arr[d] 的左边。

那么我们看 c ~ d 之间，有没有可能有一个 k 使得 arr[k] > arr[d]？

此时我们知道 arr[c] > arr[d]，arr[k] > arr[d]，因此我们需要讨论一下 arr[c] 和 arr[k] 的关系：

- 如果 arr[k] > arr[c]，因为 k 一定比 c 后遍历到，因此在遍历到 k 时一定会让 c 弹栈，等遍历到 d 让 d 压栈时根本碰不到 c，因此这种情况不可能。
- 如果 arr[k] == arr[c]，因为 k 一定比 c 后遍历到，因此在遍历到 k 时一定会让 k 连接到 c 后面，等遍历到 e 让 d 弹栈时，d 就会对 k 收集左边的信息，而不是 c，因此这种情况不可能。
- 如果 arr[k] < arr[c]，因为 k 一定比 c 后遍历到，因此在遍历到 k 时 k 一定会压在 c 的上面。因为 arr[k] > arr[d]，且 d 比 k 后遍历到，因此等遍历到 d 时，d 压栈时一定会和 c 的下标链表之间隔一个 k，d 和 c 根本不会相邻，因此这种情况也不可能。





## 7. 代码实现

```go
type record struct {
	left  int
	right int
}

func GetRecord1(arr []int) []*record {
	sk := make([][]int, 0, len(arr))
	res := make([]*record, len(arr))

	sk = append(sk, []int{0})
	for i := 1; i < len(arr); i++ {
		l := len(sk)
		last := len(sk[l-1])
		lastVal := sk[l-1][last-1]
		if l == 0 || arr[i] < arr[lastVal] {
			//1.如果栈空或者arr[i]小于栈顶下标链表对应的元素的值，直接压栈
			sk = append(sk, []int{i})
		} else if arr[i] == arr[lastVal] {
			//2.如果arr[i]等于栈顶下标链表对应的元素的值，连接到栈顶下标链表的末尾
			sk[l-1] = append(sk[l-1], i)
		} else {
			//3.如果arr[i]大于栈顶下标链表对应的元素的值，栈顶下标链表弹栈
			//直到arr[i]小于等于栈顶下标链表对应的元素值为止
			//for arr[i] > arr[lastVal] && l != 0 {
			for arr[i] > arr[lastVal] {
				curArr := sk[l-1]
				sk = sk[:l-1]
				l = len(sk)

				var left int
				if l == 0 { //是否是栈底下标链表
					left = -1
					lastVal = i //使循环break掉
				} else {
					last = len(sk[l-1])
					lastVal = sk[l-1][last-1]
					left = lastVal
				}

				for _, item := range curArr {
					res[item] = &record{left: left, right: i}
				}
			}

			//加入当前遍历的值
			if len(sk) == 0 || arr[i] < arr[lastVal] {
				sk = append(sk, []int{i})
			} else if arr[i] == arr[lastVal] {
				sk[l-1] = append(sk[l-1], i)
			}
		}
	}

	//清算阶段
	for l := len(sk); l != 0; {
		curArr := sk[l-1]
		sk = sk[:l-1]
		l = len(sk)

		right := -1
		var left int
		if l == 0 { //是否是栈底下标链表
			left = -1
		} else {
			last := len(sk[l-1])
			left = sk[l-1][last-1]
		}
		for _, item := range curArr {
			res[item] = &record{left: left, right: right}
		}
	}

	return res
}
```

